## 简单总结实现的功能
在实验lab1(ch3)中，实现了新的系统调用```sys_task_info```。该系统调用的功能是：当用户程序调用它时，会返回当前用户程序（任务）的信息：
- 该任务当前执行状态```TaskStatus```，不出错的情况下恒为```Running```。
- 该任务当前每个系统调用的调用次数，可以用系统调用号来索引获取相应的调用次数。
- 该任务从加载时刻到使用系统调用```sys_task_info```所花费的时间（ms）。
## 问答作业
1. 有的用户程序访问了非法地址，抛出访存错误，之后被内核杀掉转去下一个用户程序。有的用户程序访问了S态的寄存器sstaus、使用S态指令sret，抛出指令错误后，转而执行下一个用户程序。
2. trap.S分析
   - 2.1 刚进入```__restore```时，a0 代表的是内核栈栈顶指针。```__restore```的两种使用情况是：第一种是在任务第一次加载时通过```__restore```进入到用户态执行，第二种是在发生系统调用后通过```__restore```恢复。
   - 2.2 处理了```sstatus, sepc, sscratch```寄存器。其中```sstatus```表示当前 trap 发生的所在特权级，也即是用户态 U；```sepc```记录的是用户态发生trap前的最后一条指令，系统调用返回后，需要把 pc 设置为sepc的下一条指令；```sscratch```指向的是用户栈，需要将当前```sp```指向它，从而在进入用户态后可以使用```sp```访问用户栈。
   - 2.3 跳过x2 是因为x2是指向的内核栈，我们已经有sscratch保存内核栈指针了，所以不需要x2。跳过x4是因为x4即为tp(thread pointer)，应用程序不需要用到它，所以不需要保存。
   - 2.4 在执行它之前，```sp```是指向内核栈的，```sscratch```是指向用户栈的，在执行之后，二者发生交换，```sp```指向用户栈，```sscratch```指向内核栈。
   - 2.5 ```restore```中发生状态切换的指令是```sret```。该指令返回到被中断打断的地方继续执行，硬件会把```sstatus.sie```字段恢复为 ```sstatus.spie```字段内的值。
   - 2.6 执行L13的指令之后，```sp```会指向内核栈，```sscratch```执行用户栈。
   - 2.7 ```ecall```指令会从用户态进入内核态。
## 荣誉准则
1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：无。
2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：无。
3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。
4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。